export { stream };
import { AsyncLocalStorage } from 'node:async_hooks';
import { isServer } from './index.js'
import { serverCtx, setCtx, getCtx } from './dad_server_ctx.js';

const DEBUG = false;

////////// ASYNC SERVER STATE CONTEXT ////////////
  async function runServerCTX(uid,fn) {
    if(!isServer) return null;
    let serverUID=getCtx();
    if(!serverUID) {
      serverUID = new AsyncLocalStorage();
      console.log('>>INIT AsyncLocalStorage<<');
      setCtx(serverUID);
    }
    return await serverUID.run(uid,fn);
  }
//////////////////////////////////////////////////

////////// RENDER ////////////////////////////////

  function removeAttribute(html,attr, newattr){
    // attr = style0 --> remove style0 or style0= or style0=""
    return html.replace(new RegExp(`\s*${attr}[=,"]*`, ""),'');
  }

  async function renderServerFunction(v, asyncServerComponents, compcounter) {
      let newvalue;
      const ssrid = compcounter.id++;

      let val= v();
      val = typeof val === 'function' ? val() : val;

      if(val===null) {//CLIENT ONLY
        newvalue='<!----><!--cx--><!---->';
      } 
      else if(val===false || val===''){  //don't print it, it's used to hide/show a component
        newvalue='<!---->\u200b<!---->'; //leave the space between the 2 comments; it's IMPORTANT!!
      }
      else if(val.html) {
        newvalue = await renderServer(val, asyncServerComponents, compcounter); 
        if(v.loader) newvalue = `<!--lx${ssrid}-->${newvalue}<!--lx${ssrid}-->`; //generated by Suspense
        else newvalue = `<!--${ssrid}-->${newvalue}<!--${ssrid}-->`; //normal component
      }
      else if(val instanceof Promise){
        if(v.loader) newvalue = `<!--lx${ssrid}--><!--B:${ssrid}--><!--lx${ssrid}-->`;
        else newvalue = `<!--${ssrid}--><!--B:${ssrid}--><!--${ssrid}-->`;
        asyncServerComponents.push({id:ssrid,val}); //push async component queue
      }
      else if(Array.isArray(val)){
        let htmltxt='';
        for(let i = 0; i<val.length; i++){
          htmltxt+= await renderServerFunction(()=>val[i],asyncServerComponents, compcounter);
        }
        newvalue=htmltxt //
        newvalue=`<!--${ssrid}-->${newvalue}<!--${ssrid}-->`;
      }
      else {
        newvalue=val.toString();
        newvalue=`<!---->${newvalue}<!---->`;             
      }

      return newvalue;
  }


  //@param t:                      obj {html,reactarray} from html``
  //@param asyncServerComponents:  async nodes queue
  //@param compcounter:            needed to put marked placeholders needed for hydration client side
  async function renderServer( t, asyncServerComponents, compcounter){
    if(t instanceof Promise) t = await t;
    if(typeof t === 'function') t = t();
    if(t===null || t===false) return t;
    if(t.html==null) return console.error('DAD: wrong input to renderServer',t);
    if(!asyncServerComponents) return console.error('DAD: missing renderServer args');

    let {html,reactarray} = t;

    for (let i=0; i<reactarray.length; i++) {
      let {type,key,v} = reactarray[i];
      let placeholder = `<!--rx${key}-->`;
      let newvalue;

      switch(type) {
        case 'node': 
            if(v.html === true) { //TEMPLATE: html`` which returns {html,reactarray}
                newvalue = await renderServer(v, asyncServerComponents, compcounter);
            }
            else if(typeof v === 'function') {
                newvalue = await renderServerFunction(v, asyncServerComponents, compcounter);
            }
            else if(v instanceof Promise) {
                console.error('DAD: wrap async component in ()=>{}');
            }
            else if(v.signal) {
                newvalue = `<!>${v.value}<!>`;
            }
            else console.error('DAD: unknown node value',v);
          break;

        case '@':
            html = removeAttribute(html,key+i);
          break;

        case ':':
            if(key==='key' || key==='ref')
              html = removeAttribute(html,key+i);
            else {
              const val = typeof v ==='function' ? v() : v.value;
              const tag = `${key+i}=""`;
              
              let newtag;
              if (val === true) newtag = `${key}="${key}"`;
              else if (val === false) newtag=null;
              else if (val !== false && val != null) newtag = `${key}="${val}"`;
              else newtag=null;

              if(newtag) html = html.replace(new RegExp(`${key+i}[=,"]*`, ""),newtag);
              else html = removeAttribute(html,key+i);
            }
          break;
        case 'for':
            const array = v.$array.signal? v.$array.value : v.$array;
            newvalue='';
            for(let i = 0; i<array.length; i++){
              newvalue+= await renderServerFunction(()=>v.$item(array[i]),asyncServerComponents, compcounter);
            }
            newvalue=`<!>${newvalue}<!>`;
          break;
      }

      if(newvalue!==undefined) {
        html = html.replace(placeholder,newvalue);
      }

    }
    return html;

  }
//////////////////////////////////////////////////


////////// STREAM ////////////////////////////////

  //IMPORTANT: t must be an uncalled Component, eg App and not App()
  async function stream(t, ctx=null) {

    const stime = DEBUG && Date.now();
    const encoder = new TextEncoder();
    const readstream = new ReadableStream({
      async start(controller) {

        const write = (chunk) => {
          controller.enqueue(encoder.encode(chunk));
        }

/*
console.log("DC",a,b);\
console.log(a,b,"lx"+(parseInt(a?.data?.replace("B:",""))-1),c);\
*/
//if(c && b.content.firstChild?.data!=="cx") {\

        write(
'<script>function $DC(a,b){\
a=document.evaluate("//comment()[.=\'"+a+"\']",document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue;\
b=document.getElementById(b);\
const c=document.evaluate("//comment()[.=\'lx"+(parseInt(a?.data?.replace("B:",""))-1)+"\']",document,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue;\
if(c && b.content.firstChild?.data!=="cx") {\
while(!(c.nodeType===8&&c.nextSibling.data===(c.data))){\
c.nextSibling.remove();\
}}\
a?.replaceWith(...b.content.childNodes);\
b.nextSibling.remove();\
b.remove();\
};</script>'.replace(/\s{2,}/g, ''));

        const uid=crypto.randomUUID(); //unique session id
        try{
          let asyncServerComponents = [];
          const compcounter = { id:0 }; //component counter
          let sctx = {  
                        server: { write, suid:ctx.suid }, //needed by serverFetch: suid for "internal" authentication and write to stream _data_ for client side hydration
                        session: { uid, url:ctx.url, user:ctx.user },
                      };
          serverCtx.set(uid,sctx);
 
          if(typeof t === 'function' && !t.html) t=await runServerCTX(uid,t); //will call ()=>App()
          if(typeof t === 'function' && t.html) t=t(); //resolve html``
          else console.error('DAD: wrap stream input in ()=>comp()');

          write(`<script>window._ctx_=${JSON.stringify({...sctx.session})}</script>`);
          let serverhtml = await runServerCTX(uid,()=>renderServer( t, asyncServerComponents, compcounter ));
          write(`<div id="root">${serverhtml}</div>`);

          ////////////////////////////////
          //SAFARI BUG: requires a minimum of aroung 512bytes of data to enable streaming [https://github.com/sveltejs/kit/issues/10541]
          const safaribugcounter = 550-serverhtml.replace(/[^0-9a-zA-Z\s]/gi, "").length;
          if(safaribugcounter>0) write(`<div style="height:0px;">${'\u200b'.repeat(safaribugcounter)}</div>`);
          ////////////////////////////////



              function streamAsyncHtml(id,html){
                write(`<template id="S:${id}">${html}</template><script>$DC("B:${id}","S:${id}")</script>`);
              }

              async function asyncRender(asyncComp){ //rendering for `<!--B:${a.id}-->`
                  const {id,val} = asyncComp; //val will hold a Promise
                  let load = await val;

                  if(!load) return streamAsyncHtml(id, `<!--cx-->`); //it's a client component, replace <rx></rx> with <cx></cx> placeholder
                  if(load.default) load = await load.default;
                  load = load() //should return a {html,reactArray} object
                  if(!load) return streamAsyncHtml(id, `<!--cx-->`); //it's a client component, replace <rx></rx> with <cx></cx> placeholder

                  let asyncServerComponents=[];
                  let newhtml = await renderServer( load, asyncServerComponents, compcounter );
                  if(!newhtml) newhtml=`<!--cx-->`;
                  streamAsyncHtml(id,newhtml);

                  //run through this component's potential nested async functions
                  await processAsyncQueue(asyncServerComponents);
              }

              async function processAsyncQueue(asyncServerComponents) {
                  let promises=[];
                  for (let asyncComp of asyncServerComponents) {
                    promises.push(asyncRender(asyncComp));
                  }
                  if(promises.length) await Promise.all(promises);
              }

          await runServerCTX(uid,async()=> await processAsyncQueue(asyncServerComponents));

          DEBUG && console.log('STREAM CLOSE========',Date.now()-stime+'ms');
          controller.close();
          serverCtx.delete(uid);
        }
        catch(err) {
          console.error('DAD: server error\n',err);
          write(`<div id="derror"><b>DAD Server ERROR</b><br/>${err.stack}</div>`);
          controller.close();
          if(uid) serverCtx.delete(uid);
        }
      }
    });
    return readstream;
  }
//////////////////////////////////////////////////

